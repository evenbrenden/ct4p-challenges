Challenge 1 (pretty much a straight lift from http://danshiebler.com/2018-11-10-category-solutions/)

Consider two functors from C to Set:

d -> C(Ld, c)
d -> D(d, Rc)

ψ is a natural transformation between these two. We want to prove that:

Ff * ψgx = ψgy * Gf

Where:

* ψ is a natural transformation from G to F (conversely, φ is a natural transformation from F to G)
* gx and gy are components of ψ (not single objects but a function, since we are going between hom-sets)
* f is a function :: x -> y (not a single object but a function, since we are going between hom-sets)
* F and G must be endofunctors from C to C and D to D, respectively (in order to compose with ψ)

Since we are precomposing f with F and G, Ff and Gf must be:

Ff :: C(Lx, c) -> C(Ly, c)
Gf :: D(x, Rc) -> D(y, Rc)

Which means that ψgx and ψgy must be:

ψgx :: D(x, Rc) -> C(Lx, c)
ψgy :: D(y, Rc) -> D(Ly, c)

Then on to prove Ff * ψgx = ψgy * Gf. Right hand side:

  ψgy * Gf
  ψgy * Gf Gx    // Precompose with Gx (the trick)
= ψgy * Gy       // Apply Gx
= ψgy * D(y, Rc) // Target of Gy
= C(Ly, c)       // Definition of ψgy

Left hand side:

  Ff * ψgx
  Ff * ψgx Gx    // Precompose with Gx (the trick)
= Ff * Fx        // Apply Gx
= Fy             // Apply Fx
= C(Ly, c)       // Target of Fy


Challenge 2

If L :: D -> C is the left adjoint of R :: C -> D and vica versa, we have an isomorphism of hom-sets in C and D:

C(Ld, c) ≅ D(d, Rc)

This holds for all c and d. Substitute d = Rc:

C((L * R)c, c) ≅ D(Rc, Rc)

We know that the right hand side must contain at least on morphism, the identity. The natural transformation between these hom-sets will map the identity morphism to an element of C((L * R)c, c), or, inserting the identity functor I, a morphism in:

C((L * R)c, Ic) = ε

This is a family of morphisms parametrized by c. They form a natural transformation between the functor I and the functor L * R. This is exactly our counit ε.


Challenge 3

The first definition: C(Ld, c) ≅ D(d, Rc) => existence of η and ε (shown in book + challenge 2)

(Half of) the second definition: Existence of η and ε => existence of φ :: C(Ld, c) -> D(d, Rc) (shown in book)

The missing piece is of the second definiton is: Existence of η and ε => existence of ψ :: D(d, Rc) -> C(Ld, c)

Pick an arbitrary morphism g in D(d, Rc). We want to define a ψ that, acting on g, produces a morphism in C(Ld, c).

There isn’t really much choice. One thing we can try is to lift g using L. That will produce a morphism Lg from Ld to L(Rc) - a morphism that's an element of C(Ld, (L * R)c).

What we need for a component of ψ, is a morphism from Ld to c. That’s not a problem, since we can use a component of εc to get from Ld to (L * R)c. We get:

ψg = Rg * εc


Challenge 4

SKIPPED


Challenge 5

SKIPPED


Challenge 6

product2Function :: ((z, a) -> b) -> (z -> (a -> b)
product2Function za_b = \z -> (\a -> za_b (z, a))

function2Product :: (z -> (a -> b)) -> ((z, a) -> b)
function2Product z_ab = \za -> (z_ab (fst za) (snd za))
