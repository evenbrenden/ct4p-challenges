Challenge 1 (pretty much a straight lift from http://danshiebler.com/2018-11-10-category-solutions/)

Consider two functors from C to Set:

d -> C(Ld, c)
d -> D(d, Rc)

ψ is a natural transformation between these two. We want to prove that:

Ff * ψgx = ψgy * Gf

Where:

* ψ is a natural transformation from G to F (conversely, φ is a natural transformation from F to G)
* gx and gy are components of ψ (not single objects but a function, since we are going between hom-sets)
* f is a function :: x -> y (not a single object but a function, since we are going between hom-sets)
* F and G must be endofunctors from C to C and D to D, respectively (in order to compose with ψ)

Since we are precomposing f with F and G, Ff and Gf must be:

Ff :: C(Lx, c) -> C(Ly, c)
Gf :: D(x, Rc) -> D(y, Rc)

Which means that ψgx and ψgy must be:

ψgx :: D(x, Rc) -> C(Lx, c)
ψgy :: D(y, Rc) -> D(Ly, c)

And gx and gy must be:

gx :: x -> Rc
gy :: y -> Rc

Now we are ready to prove Ff * ψgx = ψgy * Gf. Right hand side:

  ψgy * Gf
  ψgy * Gf Gx    // Precompose with Gx (the trick)
= ψgy * Gy       // "Apply" Gx to Gf
= ψgy * D(y, Rc) // Target of Gy is D(y, Rc)
= C(Ly, c)       // "Apply" D(y, Rc) to ψgy

Left hand side:

  Ff * ψgx
  Ff * ψgx Gx    // Precompose with Gx (the trick)
= Ff * Fx        // "Apply" Gx to ψgx
= Fy             // "Apply" Fx to Ff
= C(Ly, c)       // Target of Fy is C(Ly, c)

All together:

Ff * ψgx Gx = C(Ly, c) = ψgy * Gf Gx   // Left versus right hand side
Ff * ψgx Gf Gx Gx-1 = ψgy * Gf Gx Gx-1 // Precompose with Gx-1
ψgy * Gf = Ff * ψgx Gf                 // Gf Gf-1 is identity


Challenge 2

If L :: D -> C is the left adjoint of R :: C -> D and vica versa, we have an isomorphism of hom-sets in C and D:

C(Ld, c) ≅ D(d, Rc)

This holds for all c and d. Substitute d = Rc:

C((L * R)c, c) ≅ D(Rc, Rc)

We know that the right hand side must contain at least on morphism, the identity. The natural transformation between these hom-sets will map the identity morphism to an element of C((L * R)c, c), or, inserting the identity functor I, a morphism in:

C((L * R)c, Ic) = ε

This is a family of morphisms parametrized by c. They form a natural transformation between the functor I and the functor L * R. This is exactly our counit ε.


Challenge 3

The first definition: C(Ld, c) ≅ D(d, Rc) => existence of η and ε (shown in book + challenge 2)

(Half of) the second definition: Existence of η and ε => existence of φ :: C(Ld, c) -> D(d, Rc) (shown in book)

The missing piece is of the second definiton is: Existence of η and ε => existence of ψ :: D(d, Rc) -> C(Ld, c)

Pick an arbitrary morphism g in D(d, Rc). We want to define a ψ that, acting on g, produces a morphism in C(Ld, c).

There isn’t really much choice. One thing we can try is to lift g using L. That will produce a morphism Lg from Ld to L(Rc) - a morphism that's an element of C(Ld, (L * R)c).

What we need for a component of ψ, is a morphism from Ld to c. That’s not a problem, since we can use a component of εc to get from Ld to (L * R)c. We get:

ψg = Rg * εc


Challenges 4 and 5 (also heavily inspired by http://danshiebler.com/2018-11-10-category-solutions/)

Let C be a category with an object Either a b, an object c and a morphism m in C(Either a b, c). Let CxC be a product category with an object <a, b>, an object <c, c> and morphisms <i, j>, where i :: a -> c and j :: b -> c. Let Δc :: C -> CxC be the diagonal functor whose action on objects is Δc = <c, c>. Then the Coproduct :: CxC -> C is a functor that maps <a, b> to Either a b, and we want to show that:

(CxC)(<a, b>, Δc) ≅ C(Either a b, c)

(See drawing.)

The factorizer for Coproduct (as Either) is:

factorizer :: (a -> c) -> (b -> c) -> (Either a b -> c)
factorizer i j (Left a) = i a
factorizer i j (Right b) = j b

It produces a morphism m :: Either a b -> c.

But we have chosen CxC as the source category (maybe we could have chosen a different one). If factorizer is going to serve as a natural transformation between CxC and C, we need to pair up the argument functions:

factorizer' :: ((a -> c), (b -> c)) -> (Either a b -> c)
factorizer' (i, j) (Left a) = i a
factorizer' (i, j) (Right b) = j b

To get the inverse of this we switch the arguments:

factorizer_inv' :: (Either a b -> c) -> ((a -> c), (b -> c))
factorizer_inv' eabc = (\a -> eabc (Left a), \b -> eabc (Right b))

Since this is implemented we get naturality in a, b and c for free.


Challenge 6

product2Function :: ((z, a) -> b) -> (z -> (a -> b)
product2Function za_b = \z -> (\a -> za_b (z, a))

function2Product :: (z -> (a -> b)) -> ((z, a) -> b)
function2Product z_ab = \za -> (z_ab (fst za) (snd za))
